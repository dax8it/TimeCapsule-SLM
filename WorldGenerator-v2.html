<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI World Generator - Modern SLMs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 60px 1fr 120px;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }
        
        .header {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }
        
        .world-canvas {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .controls-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
        }
        
        .ai-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .chat-interface {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn.loading {
            background: #f39c12;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .input-group input, .input-group select, .input-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        .model-info {
            background: rgba(0, 100, 200, 0.1);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .world-display {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            min-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .world-map {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #2d5a87, #1e3c72);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .location {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #fff;
        }
        
        .location:hover {
            transform: scale(1.5);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
        }
        
        .status {
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        #chatInput {
            flex: 1;
            padding: 10px;
            border: 1px solid #555;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        .ai-response {
            background: rgba(76, 175, 80, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            border-left: 3px solid #4CAF50;
        }
        
        .user-message {
            background: rgba(33, 150, 243, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            border-left: 3px solid #2196F3;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç AI World Generator - Modern SLMs</h1>
            <div>
                <span id="modelStatus">Model: Select and Load</span>
                <button id="initModel" class="btn">Load Model</button>
            </div>
        </div>
        
        <div class="world-canvas">
            <div class="world-map" id="worldMap">
                <div class="loading" id="worldLoading">
                    <div class="spinner"></div>
                    <p>Generating world...</p>
                </div>
            </div>
        </div>
        
        <div class="controls-panel">
            <div class="input-group">
                <label for="modelSelect">ü§ñ AI Model:</label>
                <select id="modelSelect">
                    <option value="phi-3-mini">Phi-3-Mini (3.8B) - Best Overall</option>
                    <option value="gemma-2b">Gemma-2B (2B) - Fast & Efficient</option>
                    <option value="qwen2-0.5b">Qwen2-0.5B (0.5B) - Ultra Fast</option>
                    <option value="tinyllama">TinyLlama (1.1B) - Lightweight</option>
                    <option value="smollm">SmolLM (1.7B) - Optimized</option>
                </select>
                <div id="modelDescription" class="model-info">
                    Microsoft's latest small model with excellent instruction following and reasoning capabilities. ~2.4GB download.
                </div>
            </div>
            
            <h3>World Settings</h3>
            
            <div class="input-group">
                <label for="worldType">World Type:</label>
                <select id="worldType">
                    <option value="fantasy">Fantasy</option>
                    <option value="scifi">Sci-Fi</option>
                    <option value="modern">Modern</option>
                    <option value="post-apocalyptic">Post-Apocalyptic</option>
                    <option value="steampunk">Steampunk</option>
                </select>
            </div>
            
            <div class="input-group">
                <label for="worldSize">World Size:</label>
                <select id="worldSize">
                    <option value="small">Small (5 locations)</option>
                    <option value="medium" selected>Medium (10 locations)</option>
                    <option value="large">Large (20 locations)</option>
                </select>
            </div>
            
            <div class="input-group">
                <label for="worldTheme">Theme:</label>
                <input type="text" id="worldTheme" placeholder="e.g., 'floating islands', 'cyberpunk city'">
            </div>
            
            <button id="generateWorld" class="btn">üé≤ Generate New World</button>
            <button id="saveWorld" class="btn">üíæ Save World</button>
            <button id="loadWorld" class="btn">üìÅ Load World</button>
            
            <div class="status" id="status">
                Select and load an AI model to begin!
            </div>
        </div>
        
        <div class="ai-panel">
            <h3>AI Assistant</h3>
            <div class="world-display" id="worldInfo">
                <p>Welcome to the AI World Generator with Modern Small Language Models!</p>
                <p><strong>Available Models:</strong></p>
                <p>‚Ä¢ <strong>Phi-3-Mini:</strong> Microsoft's latest, best overall performance</p>
                <p>‚Ä¢ <strong>Gemma-2B:</strong> Google's efficient model, fast inference</p>
                <p>‚Ä¢ <strong>Qwen2-0.5B:</strong> Ultra-lightweight, very fast</p>
                <p>‚Ä¢ <strong>TinyLlama:</strong> Compact, good for basic tasks</p>
                <p>‚Ä¢ <strong>SmolLM:</strong> Optimized for instruction following</p>
                <hr style="margin: 10px 0;">
                <p>1. Select an AI model above</p>
                <p>2. Click "Load Model" (downloads on first use)</p>
                <p>3. Configure world settings</p>
                <p>4. Generate your world!</p>
            </div>
        </div>
        
        <div class="chat-interface">
            <input type="text" id="chatInput" placeholder="Ask the AI about your world or request changes...">
            <button id="sendChat" class="btn">Send</button>
        </div>
    </div>

    <script type="module">
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1';
        
        env.allowRemoteModels = true;
        env.allowLocalModels = false;
        
        class ModernWorldGenerator {
            constructor() {
                this.generator = null;
                this.currentWorld = null;
                this.isGenerating = false;
                this.isLoadingModel = false;
                this.currentModel = 'phi-3-mini';
                
                this.availableModels = {
                    'phi-3-mini': {
                        name: 'Phi-3-Mini (3.8B)',
                        model: 'microsoft/Phi-3-mini-4k-instruct',
                        size: '~2.4GB',
                        description: 'Microsoft\'s latest small model with excellent instruction following and reasoning capabilities. Best overall performance.'
                    },
                    'gemma-2b': {
                        name: 'Gemma-2B (2B)',
                        model: 'google/gemma-2b-it',
                        size: '~1.6GB', 
                        description: 'Google\'s efficient small model with good reasoning and multilingual support. Fast inference.'
                    },
                    'qwen2-0.5b': {
                        name: 'Qwen2-0.5B (0.5B)',
                        model: 'Qwen/Qwen2-0.5B-Instruct',
                        size: '~0.5GB',
                        description: 'Ultra-fast and lightweight model by Alibaba. Excellent for quick responses and low-resource environments.'
                    },
                    'tinyllama': {
                        name: 'TinyLlama (1.1B)',
                        model: 'TinyLlama/TinyLlama-1.1B-Chat-v1.0',
                        size: '~0.7GB',
                        description: 'Compact and efficient model based on Llama architecture. Good balance of size and capability.'
                    },
                    'smollm': {
                        name: 'SmolLM (1.7B)',
                        model: 'HuggingFaceTB/SmolLM-1.7B-Instruct',
                        size: '~1.1GB',
                        description: 'Hugging Face\'s optimized model for instruction following and reasoning tasks. High efficiency.'
                    }
                };
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.updateModelDescription();
                this.updateStatus('Select an AI model and click "Load Model" to begin!');
            }
            
            setupEventListeners() {
                document.getElementById('modelSelect').addEventListener('change', (e) => {
                    this.currentModel = e.target.value;
                    this.updateModelDescription();
                    if (this.generator) {
                        document.getElementById('modelStatus').textContent = 'Model: Different model selected';
                        document.getElementById('initModel').textContent = 'Load New Model';
                        this.generator = null;
                    }
                });
                
                document.getElementById('initModel').addEventListener('click', () => this.loadModel());
                document.getElementById('generateWorld').addEventListener('click', () => this.generateWorld());
                document.getElementById('sendChat').addEventListener('click', () => this.handleChat());
                document.getElementById('chatInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleChat();
                });
                document.getElementById('saveWorld').addEventListener('click', () => this.saveWorld());
                document.getElementById('loadWorld').addEventListener('click', () => this.loadWorld());
            }
            
            updateModelDescription() {
                const model = this.availableModels[this.currentModel];
                document.getElementById('modelDescription').innerHTML = `
                    <strong>${model.name}</strong> (${model.size})<br>
                    ${model.description}
                `;
            }
            
            async loadModel() {
                if (this.isLoadingModel) return;
                if (this.generator) {
                    this.updateStatus('Model already loaded!');
                    return;
                }
                
                this.isLoadingModel = true;
                const selectedModel = this.availableModels[this.currentModel];
                
                try {
                    document.getElementById('modelStatus').textContent = `Loading ${selectedModel.name}...`;
                    document.getElementById('initModel').disabled = true;
                    document.getElementById('initModel').textContent = 'Loading...';
                    this.updateStatus(`Downloading ${selectedModel.name} (${selectedModel.size})... This may take a few minutes on first load.`);
                    
                    this.generator = await pipeline('text-generation', selectedModel.model, {
                        dtype: 'q4',
                        device: 'webgpu',
                    });
                    
                    document.getElementById('modelStatus').textContent = `Model: ${selectedModel.name} Ready`;
                    document.getElementById('initModel').disabled = false;
                    document.getElementById('initModel').textContent = 'Model Loaded ‚úì';
                    this.updateStatus(`${selectedModel.name} loaded successfully! Ready to generate worlds.`);
                    
                } catch (error) {
                    console.error('Error loading model:', error);
                    
                    try {
                        this.updateStatus('WebGPU failed, trying CPU fallback...');
                        this.generator = await pipeline('text-generation', selectedModel.model, {
                            dtype: 'q8',
                            device: 'cpu',
                        });
                        
                        document.getElementById('modelStatus').textContent = `Model: ${selectedModel.name} Ready (CPU)`;
                        document.getElementById('initModel').disabled = false;
                        document.getElementById('initModel').textContent = 'Model Loaded ‚úì';
                        this.updateStatus(`${selectedModel.name} loaded successfully on CPU!`);
                        
                    } catch (fallbackError) {
                        console.error('Fallback loading failed:', fallbackError);
                        document.getElementById('modelStatus').textContent = 'Model: Load Failed';
                        document.getElementById('initModel').disabled = false;
                        document.getElementById('initModel').textContent = 'Retry Load';
                        this.updateStatus('Failed to load model. Using template-based generation.');
                    }
                }
                
                this.isLoadingModel = false;
            }
            
            async generateWorld() {
                if (this.isGenerating) return;
                
                this.isGenerating = true;
                this.showLoading(true);
                this.updateStatus('Generating world...');
                
                const worldType = document.getElementById('worldType').value;
                const worldSize = document.getElementById('worldSize').value;
                const worldTheme = document.getElementById('worldTheme').value;
                
                try {
                    let worldDescription = '';
                    
                    if (this.generator) {
                        const prompt = this.createWorldPrompt(worldType, worldTheme);
                        
                        const result = await this.generator(prompt, {
                            max_new_tokens: 200,
                            temperature: 0.8,
                            do_sample: true,
                            top_p: 0.9,
                            repetition_penalty: 1.1
                        });
                        
                        worldDescription = result[0].generated_text.replace(prompt, '').trim();
                    } else {
                        worldDescription = this.generateFallbackDescription(worldType, worldTheme);
                    }
                    
                    this.currentWorld = {
                        type: worldType,
                        size: worldSize,
                        theme: worldTheme,
                        description: worldDescription,
                        locations: this.generateLocations(worldSize, worldType),
                        model: this.currentModel,
                        created: new Date().toISOString()
                    };
                    
                    this.displayWorld();
                    this.renderWorldMap();
                    this.updateStatus('World generated successfully!');
                    
                } catch (error) {
                    console.error('Error generating world:', error);
                    this.updateStatus('Error generating world. Using fallback generation.');
                    this.generateFallbackWorld();
                }
                
                this.isGenerating = false;
                this.showLoading(false);
            }
            
            createWorldPrompt(worldType, worldTheme) {
                const prompts = {
                    'phi-3-mini': `<|user|>\nCreate a detailed ${worldType} world description${worldTheme ? ' with the theme: ' + worldTheme : ''}. Make it immersive and unique.\n<|assistant|>\n`,
                    'gemma-2b': `<start_of_turn>user\nDescribe a ${worldType} world${worldTheme ? ' themed around ' + worldTheme : ''}. Make it vivid and engaging.\n<start_of_turn>model\n`,
                    'qwen2-0.5b': `<|im_start|>system\nYou are a creative world builder.<|im_end|>\n<|im_start|>user\nCreate a ${worldType} world${worldTheme ? ' with theme: ' + worldTheme : ''}.<|im_end|>\n<|im_start|>assistant\n`,
                    'tinyllama': `### User:\nDescribe a ${worldType} world${worldTheme ? ' themed around ' + worldTheme : ''}.\n\n### Assistant:\n`,
                    'smollm': `<|im_start|>user\nCreate a detailed ${worldType} world description${worldTheme ? ' with theme: ' + worldTheme : ''}.<|im_end|>\n<|im_start|>assistant\n`
                };
                
                return prompts[this.currentModel] || prompts['tinyllama'];
            }
            
            generateFallbackDescription(worldType, worldTheme) {
                const templates = {
                    fantasy: "A mystical realm where ancient magic flows through every corner. Towering castles rise from mist-covered valleys, while enchanted forests whisper secrets of old. Dragons soar through crystal-clear skies, and magical creatures roam freely across the land.",
                    scifi: "A futuristic universe spanning multiple star systems. Advanced civilizations have mastered space travel, creating sprawling space stations and terraformed planets. Artificial intelligence coexists with organic life forms in this technological marvel.",
                    modern: "A contemporary world of bustling metropolises connected by advanced infrastructure. Digital networks span the globe, while diverse cultures blend in cosmopolitan cities. Innovation drives progress in this interconnected society.",
                    'post-apocalyptic': "A harsh wasteland where civilization struggles to rebuild after The Great Catastrophe. Survivors band together in fortified settlements, scavenging resources while facing the constant threat of radiation, mutants, and rival factions.",
                    steampunk: "A Victorian-era world powered by magnificent steam technology. Brass gears turn in massive clockwork machines while airships drift through smog-filled skies. Inventors and engineers shape society through mechanical marvels and pneumatic innovation."
                };
                
                let description = templates[worldType] || templates.fantasy;
                if (worldTheme) {
                    description += ` This world is particularly known for its ${worldTheme}, which influences every aspect of life and culture.`;
                }
                
                return description;
            }
            
            generateFallbackWorld() {
                const worldType = document.getElementById('worldType').value;
                const worldSize = document.getElementById('worldSize').value;
                const worldTheme = document.getElementById('worldTheme').value;
                
                this.currentWorld = {
                    type: worldType,
                    size: worldSize,
                    theme: worldTheme,
                    description: this.generateFallbackDescription(worldType, worldTheme),
                    locations: this.generateLocations(worldSize, worldType),
                    model: 'fallback',
                    created: new Date().toISOString()
                };
                
                this.displayWorld();
                this.renderWorldMap();
            }
            
            generateLocations(size, worldType) {
                const counts = { small: 5, medium: 10, large: 20 };
                const count = counts[size] || 10;
                const locations = [];
                
                const locationTypes = {
                    fantasy: ['Ancient Castle', 'Mystical Forest', 'Dragon\'s Lair', 'Wizard Tower', 'Elven Village', 'Dwarven Mines', 'Sacred Temple', 'Haunted Ruins', 'Crystal Cave', 'Magical Library', 'Floating Island', 'Enchanted Lake'],
                    scifi: ['Space Station Alpha', 'Colony New Terra', 'Research Lab Omega', 'Mining Facility Zeta', 'Wormhole Gate', 'Cybernetic City', 'Orbital Platform', 'Quantum Institute', 'Bio-Dome Paradise', 'Starship Graveyard', 'Alien Embassy', 'Fusion Reactor'],
                    modern: ['Metropolitan Center', 'University Campus', 'Industrial District', 'Residential Heights', 'Shopping Complex', 'International Airport', 'Medical Center', 'Government Plaza', 'Central Park', 'Tech Innovation Hub', 'Financial District', 'Cultural Quarter'],
                    'post-apocalyptic': ['Haven Settlement', 'Ruined Metropolis', 'Military Bunker X-7', 'Raider Stronghold', 'Wasteland Outpost', 'Radiation Zone Omega', 'Scavenger Market', 'Hidden Vault 101', 'Toxic Marshlands', 'Abandoned Factory', 'Survivor Camp', 'Dead Zone'],
                    steampunk: ['Clockwork Metropolis', 'Steam Foundry', 'Airship Docks', 'Inventor\'s Quarter', 'Gear Gardens', 'Steam Cathedral', 'Mechanical Theater', 'Brass Observatory', 'Pneumatic Network', 'Automaton Workshop', 'Coal District', 'Pressure Chamber']
                };
                
                const typeLocations = locationTypes[worldType] || locationTypes.fantasy;
                
                for (let i = 0; i < count; i++) {
                    const locationType = typeLocations[i % typeLocations.length];
                    locations.push({
                        id: i,
                        name: locationType,
                        x: Math.random() * 70 + 15,
                        y: Math.random() * 70 + 15,
                        description: this.generateLocationDescription(locationType, worldType)
                    });
                }
                
                return locations;
            }
            
            generateLocationDescription(locationType, worldType) {
                const descriptions = {
                    fantasy: {
                        'Ancient Castle': 'A towering fortress with stone walls that have witnessed countless battles and royal ceremonies.',
                        'Mystical Forest': 'Dense woodlands where ancient trees whisper magical secrets and mythical creatures dwell.',
                        'Dragon\'s Lair': 'A cavern filled with treasure, guarded by a mighty dragon that breathes elemental fire.',
                        'Wizard Tower': 'A tall spire crackling with arcane energy, home to powerful spellcasters and their experiments.',
                        'Elven Village': 'An elegant settlement built in harmony with nature, where graceful elves practice ancient arts.'
                    },
                    scifi: {
                        'Space Station Alpha': 'A massive orbital facility serving as a hub for interstellar trade and research.',
                        'Colony New Terra': 'A terraformed planet settlement where humans have built a new civilization.',
                        'Research Lab Omega': 'A cutting-edge facility where scientists push the boundaries of known technology.',
                        'Mining Facility Zeta': 'An automated complex extracting rare minerals from asteroid fields.',
                        'Cybernetic City': 'A metropolis where technology and biology merge in perfect harmony.'
                    }
                };
                
                const typeDescriptions = descriptions[worldType];
                if (typeDescriptions && typeDescriptions[locationType]) {
                    return typeDescriptions[locationType];
                }
                
                return `A significant ${locationType.toLowerCase()} that plays an important role in this ${worldType} world.`;
            }
            
            displayWorld() {
                const worldInfo = document.getElementById('worldInfo');
                const modelBadge = this.currentWorld.model !== 'fallback' ? 
                    `<span style="background: #4CAF50; padding: 2px 6px; border-radius: 3px; font-size: 10px;">${this.availableModels[this.currentWorld.model]?.name || this.currentWorld.model}</span>` : 
                    `<span style="background: #FF9800; padding: 2px 6px; border-radius: 3px; font-size: 10px;">Template</span>`;
                
                worldInfo.innerHTML = `
                    <h4>üåç ${this.currentWorld.type.charAt(0).toUpperCase() + this.currentWorld.type.slice(1)} World ${modelBadge}</h4>
                    <p><strong>Theme:</strong> ${this.currentWorld.theme || 'None specified'}</p>
                    <p><strong>Size:</strong> ${this.currentWorld.size} (${this.currentWorld.locations.length} locations)</p>
                    <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                        <strong>Description:</strong><br>
                        ${this.currentWorld.description}
                    </div>
                    <hr style="margin: 15px 0; border: 1px solid rgba(255,255,255,0.2);">
                    <h5>üó∫Ô∏è Locations:</h5>
                    <div style="max-height: 150px; overflow-y: auto;">
                        ${this.currentWorld.locations.map(loc => `
                            <div style="margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.03); border-radius: 3px; cursor: pointer;" onclick="worldGen.showLocationDetails('${loc.name}')">
                                <strong>${loc.name}</strong><br>
                                <small>${loc.description}</small>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            renderWorldMap() {
                const worldMap = document.getElementById('worldMap');
                worldMap.innerHTML = '';
                
                this.currentWorld.locations.forEach((location, index) => {
                    const locationElement = document.createElement('div');
                    locationElement.className = 'location';
                    locationElement.style.left = `${location.x}%`;
                    locationElement.style.top = `${location.y}%`;
                    locationElement.title = location.name;
                    
                    const colors = ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336', '#00BCD4', '#8BC34A', '#FFC107', '#E91E63', '#3F51B5'];
                    locationElement.style.background = colors[index % colors.length];
                    
                    locationElement.addEventListener('click', () => {
                        this.showLocationDetails(location.name);
                    });
                    
                    worldMap.appendChild(locationElement);
                });
            }
            
            showLocationDetails(locationName) {
                const chatInput = document.getElementById('chatInput');
                chatInput.value = `Tell me more about ${locationName}`;
                this.handleChat();
            }
            
            async handleChat() {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                if (!message) return;
                
                const worldInfo = document.getElementById('worldInfo');
                
                const userMessage = document.createElement('div');
                userMessage.className = 'user-message';
                userMessage.innerHTML = `<strong>You:</strong> ${message}`;
                worldInfo.appendChild(userMessage);
                
                input.value = '';
                
                try {
                    let response = '';
                    
                    if (this.generator && this.currentWorld) {
                        const prompt = this.createChatPrompt(message);
                        
                        const result = await this.generator(prompt, {
                            max_new_tokens: 100,
                            temperature: 0.7,
                            do_sample: true,
                            top_p: 0.9
                        });
                        
                        response = result[0].generated_text.replace(prompt, '').trim();
                    } else if (this.currentWorld) {
                        response = this.generateFallbackResponse(message);
                    } else {
                        response = 'I need a world to be generated first! Please click "Generate New World" to create a world I can discuss.';
                    }
                    
                    const aiResponse = document.createElement('div');
                    aiResponse.className = 'ai-response';
                    aiResponse.innerHTML = `<strong>AI:</strong> ${response}`;
                    worldInfo.appendChild(aiResponse);
                    
                } catch (error) {
                    console.error('Error in chat:', error);
                    const aiResponse = document.createElement('div');
                    aiResponse.className = 'ai-response';
                    aiResponse.innerHTML = '<strong>AI:</strong> Sorry, I encountered an error. Please try again.';
                    worldInfo.appendChild(aiResponse);
                }
                
                worldInfo.scrollTop = worldInfo.scrollHeight;
            }
            
            createChatPrompt(message) {
                const context = `World: ${this.currentWorld.description}\nLocations: ${this.currentWorld.locations.map(l => l.name).join(', ')}`;
                
                const prompts = {
                    'phi-3-mini': `<|user|>\n${context}\n\nQuestion: ${message}\n<|assistant|>\n`,
                    'gemma-2b': `<start_of_turn>user\n${context}\n\nQuestion: ${message}\n<start_of_turn>model\n`,
                    'qwen2-0.5b': `<|im_start|>user\n${context}\n\nQuestion: ${message}\n<|im_end|>\n<|im_start|>assistant\n`,
                    'tinyllama': `### Context:\n${context}\n\n### Question: ${message}\n\n### Answer:\n`,
                    'smollm': `<|im_start|>user\n${context}\n\nQuestion: ${message}\n<|im_end|>\n<|im_start|>assistant\n`
                };
                
                return prompts[this.currentModel] || prompts['tinyllama'];
            }
            
            generateFallbackResponse(message) {
                const lowerMessage = message.toLowerCase();
                
                if (lowerMessage.includes('location') || lowerMessage.includes('place')) {
                    const randomLocation = this.currentWorld.locations[Math.floor(Math.random() * this.currentWorld.locations.length)];
                    return `${randomLocation.name} is particularly interesting. ${randomLocation.description} It's a key location in our ${this.currentWorld.type} world.`;
                }
                
                if (lowerMessage.includes('world') || lowerMessage.includes('describe')) {
                    return `This ${this.currentWorld.type} world is fascinating! ${this.currentWorld.description.substring(0, 100)}... Would you like to know more about any specific location?`;
                }
                
                return `That's an interesting question about our ${this.currentWorld.type} world! The world has ${this.currentWorld.locations.length} unique locations, each with its own story to tell.`;
            }
            
            saveWorld() {
                if (!this.currentWorld) {
                    this.updateStatus('No world to save!');
                    return;
                }
                
                const worldData = JSON.stringify(this.currentWorld, null, 2);
                const blob = new Blob([worldData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `world_${this.currentWorld.type}_${this.currentWorld.model}_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.updateStatus('World saved successfully!');
            }
            
            loadWorld() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                this.currentWorld = JSON.parse(e.target.result);
                                this.displayWorld();
                                this.renderWorldMap();
                                this.updateStatus('World loaded successfully!');
                            } catch (error) {
                                this.updateStatus('Error loading world file!');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }
            
            showLoading(show) {
                const loading = document.getElementById('worldLoading');
                loading.style.display = show ? 'block' : 'none';
            }
            
            updateStatus(message) {
                document.getElementById('status').textContent = message;
                setTimeout(() => {
                    if (document.getElementById('status').textContent === message) {
                        document.getElementById('status').textContent = 'Ready';
                    }
                }, 5000);
            }
        }
        
        window.worldGen = new ModernWorldGenerator();
    </script>
</body>
</html> 