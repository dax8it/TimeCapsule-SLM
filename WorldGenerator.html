<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI World Generator - Browser SLM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 60px 1fr 120px;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }
        
        .header {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }
        
        .world-canvas {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .controls-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
        }
        
        .ai-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .chat-interface {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .input-group input, .input-group select, .input-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        .world-display {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            min-height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .world-map {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #2d5a87, #1e3c72);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .location {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #fff;
        }
        
        .location:hover {
            transform: scale(1.5);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
        }
        
        .status {
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        #chatInput {
            flex: 1;
            padding: 10px;
            border: 1px solid #555;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        .ai-response {
            background: rgba(76, 175, 80, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            border-left: 3px solid #4CAF50;
        }
        
        .user-message {
            background: rgba(33, 150, 243, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            border-left: 3px solid #2196F3;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç AI World Generator</h1>
            <div>
                <span id="modelStatus">Model: Loading...</span>
                <button id="initModel" class="btn" disabled>Initialize AI</button>
            </div>
        </div>
        
        <div class="world-canvas">
            <div class="world-map" id="worldMap">
                <div class="loading" id="worldLoading">
                    <div class="spinner"></div>
                    <p>Generating world...</p>
                </div>
            </div>
        </div>
        
        <div class="controls-panel">
            <h3>World Settings</h3>
            
            <div class="input-group">
                <label for="worldType">World Type:</label>
                <select id="worldType">
                    <option value="fantasy">Fantasy</option>
                    <option value="scifi">Sci-Fi</option>
                    <option value="modern">Modern</option>
                    <option value="post-apocalyptic">Post-Apocalyptic</option>
                    <option value="steampunk">Steampunk</option>
                </select>
            </div>
            
            <div class="input-group">
                <label for="worldSize">World Size:</label>
                <select id="worldSize">
                    <option value="small">Small (5 locations)</option>
                    <option value="medium" selected>Medium (10 locations)</option>
                    <option value="large">Large (20 locations)</option>
                </select>
            </div>
            
            <div class="input-group">
                <label for="worldTheme">Theme:</label>
                <input type="text" id="worldTheme" placeholder="e.g., 'magical forest', 'space station'">
            </div>
            
            <button id="generateWorld" class="btn">üé≤ Generate New World</button>
            <button id="saveWorld" class="btn">üíæ Save World</button>
            <button id="loadWorld" class="btn">üìÅ Load World</button>
            
            <div class="status" id="status">
                Ready to generate worlds!
            </div>
        </div>
        
        <div class="ai-panel">
            <h3>AI Assistant</h3>
            <div class="world-display" id="worldInfo">
                <p>Welcome to the AI World Generator! Click "Generate New World" to create your first world.</p>
            </div>
        </div>
        
        <div class="chat-interface">
            <input type="text" id="chatInput" placeholder="Ask the AI about your world or request changes...">
            <button id="sendChat" class="btn">Send</button>
        </div>
    </div>

    <!-- Transformers.js -->
    <script type="module">
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0';
        
        // Configure environment for better performance
        env.allowRemoteModels = true;
        env.allowLocalModels = false;
        env.backends = {
            onnx: {
                wasm: {
                    wasmPaths: 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/',
                }
            }
        };
        
        class WorldGenerator {
            constructor() {
                this.generator = null;
                this.currentWorld = null;
                this.isGenerating = false;
                this.currentModel = 'phi-3-mini';
                this.availableModels = {
                    'phi-3-mini': {
                        name: 'Phi-3-Mini (3.8B)',
                        model: 'microsoft/Phi-3-mini-4k-instruct',
                        size: '~2.4GB',
                        description: 'Microsoft\'s latest small model, excellent instruction following'
                    },
                    'gemma-2b': {
                        name: 'Gemma-2B (2B)',
                        model: 'google/gemma-2b-it',
                        size: '~1.6GB',
                        description: 'Google\'s efficient small model, good reasoning'
                    },
                    'qwen2-0.5b': {
                        name: 'Qwen2-0.5B (0.5B)',
                        model: 'Qwen/Qwen2-0.5B-Instruct',
                        size: '~0.5GB',
                        description: 'Ultra-fast, very lightweight but capable'
                    },
                    'tinyllama': {
                        name: 'TinyLlama-1.1B',
                        model: 'TinyLlama/TinyLlama-1.1B-Chat-v1.0',
                        size: '~0.7GB',
                        description: 'Compact and efficient, good for basic tasks'
                    },
                    'smollm': {
                        name: 'SmolLM-1.7B',
                        model: 'HuggingFaceTB/SmolLM-1.7B-Instruct',
                        size: '~1.1GB',
                        description: 'Optimized for instruction following and reasoning'
                    }
                };
                this.init();
            }
            
            async init() {
                try {
                    this.createModelSelector();
                    document.getElementById('modelStatus').textContent = 'Model: Ready to load';
                    document.getElementById('initModel').disabled = false;
                    document.getElementById('initModel').textContent = 'Load Selected Model';
                    this.setupEventListeners();
                    this.updateStatus('Select a model and click "Load Selected Model"');
                } catch (error) {
                    console.error('Error initializing:', error);
                    this.updateStatus('Initialization error. Using fallback generation.');
                    this.setupEventListeners();
                }
            }
            
            createModelSelector() {
                const controlsPanel = document.querySelector('.controls-panel');
                const modelSelectorHTML = `
                    <div class="input-group" style="margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 15px;">
                        <label for="modelSelect" style="font-size: 14px; margin-bottom: 10px;">ü§ñ AI Model:</label>
                        <select id="modelSelect" style="margin-bottom: 10px;">
                            ${Object.entries(this.availableModels).map(([key, model]) => 
                                `<option value="${key}" ${key === this.currentModel ? 'selected' : ''}>${model.name} (${model.size})</option>`
                            ).join('')}
                        </select>
                        <div id="modelDescription" style="font-size: 12px; color: #aaa; margin-top: 5px;">
                            ${this.availableModels[this.currentModel].description}
                        </div>
                    </div>
                `;
                controlsPanel.insertAdjacentHTML('afterbegin', modelSelectorHTML);
                
                // Update description when model changes
                document.getElementById('modelSelect').addEventListener('change', (e) => {
                    this.currentModel = e.target.value;
                    document.getElementById('modelDescription').textContent = this.availableModels[this.currentModel].description;
                    document.getElementById('modelStatus').textContent = 'Model: Ready to load';
                    document.getElementById('initModel').textContent = 'Load Selected Model';
                    this.generator = null; // Reset generator
                });
            }
            
            async loadModel() {
                if (this.generator) {
                    this.updateStatus('Model already loaded!');
                    return;
                }
                
                try {
                    const selectedModel = this.availableModels[this.currentModel];
                    document.getElementById('modelStatus').textContent = `Loading ${selectedModel.name}...`;
                    document.getElementById('initModel').disabled = true;
                    this.updateStatus(`Loading ${selectedModel.name} (${selectedModel.size})...`);
                    
                    // Try to load the selected model with fallback
                    let modelId = selectedModel.model;
                    
                    // Use quantized versions when available for better performance
                    const quantizedModels = {
                        'phi-3-mini': 'microsoft/Phi-3-mini-4k-instruct',
                        'gemma-2b': 'google/gemma-2b-it', 
                        'qwen2-0.5b': 'Qwen/Qwen2-0.5B-Instruct',
                        'tinyllama': 'TinyLlama/TinyLlama-1.1B-Chat-v1.0',
                        'smollm': 'HuggingFaceTB/SmolLM-1.7B-Instruct'
                    };
                    
                    if (quantizedModels[this.currentModel]) {
                        modelId = quantizedModels[this.currentModel];
                    }
                    
                    this.generator = await pipeline('text-generation', modelId, {
                        device: 'webgpu', // Try WebGPU first for better performance
                        dtype: 'fp16',
                        revision: 'main'
                    });
                    
                    document.getElementById('modelStatus').textContent = `Model: ${selectedModel.name} Ready`;
                    document.getElementById('initModel').disabled = false;
                    document.getElementById('initModel').textContent = 'Model Loaded ‚úì';
                    this.updateStatus(`${selectedModel.name} loaded successfully!`);
                    
                } catch (error) {
                    console.error('Error loading model:', error);
                    document.getElementById('modelStatus').textContent = 'Model: Load Failed';
                    document.getElementById('initModel').disabled = false;
                    document.getElementById('initModel').textContent = 'Retry Load';
                    this.updateStatus('Failed to load model. Using fallback generation.');
                }
            }
            
            setupEventListeners() {
                document.getElementById('generateWorld').addEventListener('click', () => this.generateWorld());
                document.getElementById('sendChat').addEventListener('click', () => this.handleChat());
                document.getElementById('chatInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleChat();
                });
                document.getElementById('saveWorld').addEventListener('click', () => this.saveWorld());
                document.getElementById('loadWorld').addEventListener('click', () => this.loadWorld());
                document.getElementById('initModel').addEventListener('click', () => this.loadModel());
            }
            
            async generateWorld() {
                if (this.isGenerating) return;
                
                this.isGenerating = true;
                this.showLoading(true);
                this.updateStatus('Generating world...');
                
                const worldType = document.getElementById('worldType').value;
                const worldSize = document.getElementById('worldSize').value;
                const worldTheme = document.getElementById('worldTheme').value;
                
                try {
                    let worldDescription = '';
                    
                    if (this.generator) {
                        // Use AI to generate world description
                        const prompt = `Create a ${worldType} world description${worldTheme ? ' themed around ' + worldTheme : ''}:\n\n`;
                        
                        const result = await this.generator(prompt, {
                            max_new_tokens: 150,
                            temperature: 0.8,
                            do_sample: true,
                            pad_token_id: 50256
                        });
                        
                        worldDescription = result[0].generated_text.replace(prompt, '').trim();
                    } else {
                        // Fallback to template-based generation
                        worldDescription = this.generateFallbackDescription(worldType, worldTheme);
                    }
                    
                    // Create world data
                    this.currentWorld = {
                        type: worldType,
                        size: worldSize,
                        theme: worldTheme,
                        description: worldDescription,
                        locations: this.generateLocations(worldSize, worldType),
                        created: new Date().toISOString()
                    };
                    
                    this.displayWorld();
                    this.renderWorldMap();
                    this.updateStatus('World generated successfully!');
                    
                } catch (error) {
                    console.error('Error generating world:', error);
                    this.updateStatus('Error generating world. Using fallback generation.');
                    this.generateFallbackWorld();
                }
                
                this.isGenerating = false;
                this.showLoading(false);
            }
            
            generateFallbackDescription(worldType, worldTheme) {
                const templates = {
                    fantasy: "A mystical realm where ancient magic flows through every corner. Towering castles rise from mist-covered valleys, while enchanted forests whisper secrets of old. Dragons soar through crystal-clear skies, and magical creatures roam freely across the land.",
                    scifi: "A futuristic universe spanning multiple star systems. Advanced civilizations have mastered space travel, creating sprawling space stations and terraformed planets. Artificial intelligence coexists with organic life forms in this technological marvel.",
                    modern: "A contemporary world of bustling metropolises connected by advanced infrastructure. Digital networks span the globe, while diverse cultures blend in cosmopolitan cities. Innovation drives progress in this interconnected society.",
                    'post-apocalyptic': "A harsh wasteland where civilization struggles to rebuild after The Great Catastrophe. Survivors band together in fortified settlements, scavenging resources while facing the constant threat of radiation, mutants, and rival factions.",
                    steampunk: "A Victorian-era world powered by magnificent steam technology. Brass gears turn in massive clockwork machines while airships drift through smog-filled skies. Inventors and engineers shape society through mechanical marvels and pneumatic innovation."
                };
                
                let description = templates[worldType] || templates.fantasy;
                if (worldTheme) {
                    description += ` This world is particularly known for its ${worldTheme}, which influences every aspect of life and culture.`;
                }
                
                return description;
            }
            
            generateFallbackWorld() {
                const worldType = document.getElementById('worldType').value;
                const worldSize = document.getElementById('worldSize').value;
                const worldTheme = document.getElementById('worldTheme').value;
                
                this.currentWorld = {
                    type: worldType,
                    size: worldSize,
                    theme: worldTheme,
                    description: this.generateFallbackDescription(worldType, worldTheme),
                    locations: this.generateLocations(worldSize, worldType),
                    created: new Date().toISOString()
                };
                
                this.displayWorld();
                this.renderWorldMap();
            }
            
            generateLocations(size, worldType) {
                const counts = { small: 5, medium: 10, large: 20 };
                const count = counts[size] || 10;
                const locations = [];
                
                const locationTypes = {
                    fantasy: ['Ancient Castle', 'Mystical Forest', 'Dragon\'s Lair', 'Wizard Tower', 'Elven Village', 'Dwarven Mines', 'Sacred Temple', 'Haunted Ruins', 'Crystal Cave', 'Magical Library', 'Floating Island', 'Enchanted Lake'],
                    scifi: ['Space Station Alpha', 'Colony New Terra', 'Research Lab Omega', 'Mining Facility Zeta', 'Wormhole Gate', 'Cybernetic City', 'Orbital Platform', 'Quantum Institute', 'Bio-Dome Paradise', 'Starship Graveyard', 'Alien Embassy', 'Fusion Reactor'],
                    modern: ['Metropolitan Center', 'University Campus', 'Industrial District', 'Residential Heights', 'Shopping Complex', 'International Airport', 'Medical Center', 'Government Plaza', 'Central Park', 'Tech Innovation Hub', 'Financial District', 'Cultural Quarter'],
                    'post-apocalyptic': ['Haven Settlement', 'Ruined Metropolis', 'Military Bunker X-7', 'Raider Stronghold', 'Wasteland Outpost', 'Radiation Zone Omega', 'Scavenger Market', 'Hidden Vault 101', 'Toxic Marshlands', 'Abandoned Factory', 'Survivor Camp', 'Dead Zone'],
                    steampunk: ['Clockwork Metropolis', 'Steam Foundry', 'Airship Docks', 'Inventor\'s Quarter', 'Gear Gardens', 'Steam Cathedral', 'Mechanical Theater', 'Brass Observatory', 'Pneumatic Network', 'Automaton Workshop', 'Coal District', 'Pressure Chamber']
                };
                
                const typeLocations = locationTypes[worldType] || locationTypes.fantasy;
                
                for (let i = 0; i < count; i++) {
                    const locationType = typeLocations[i % typeLocations.length];
                    locations.push({
                        id: i,
                        name: locationType,
                        x: Math.random() * 70 + 15, // 15-85% of container width
                        y: Math.random() * 70 + 15, // 15-85% of container height
                        description: this.generateLocationDescription(locationType, worldType)
                    });
                }
                
                return locations;
            }
            
            generateLocationDescription(locationType, worldType) {
                const descriptions = {
                    fantasy: {
                        'Ancient Castle': 'A towering fortress with stone walls that have witnessed countless battles and royal ceremonies.',
                        'Mystical Forest': 'Dense woodlands where ancient trees whisper magical secrets and mythical creatures dwell.',
                        'Dragon\'s Lair': 'A cavern filled with treasure, guarded by a mighty dragon that breathes elemental fire.',
                        'Wizard Tower': 'A tall spire crackling with arcane energy, home to powerful spellcasters and their experiments.',
                        'Elven Village': 'An elegant settlement built in harmony with nature, where graceful elves practice ancient arts.'
                    },
                    scifi: {
                        'Space Station Alpha': 'A massive orbital facility serving as a hub for interstellar trade and research.',
                        'Colony New Terra': 'A terraformed planet settlement where humans have built a new civilization.',
                        'Research Lab Omega': 'A cutting-edge facility where scientists push the boundaries of known technology.',
                        'Mining Facility Zeta': 'An automated complex extracting rare minerals from asteroid fields.',
                        'Cybernetic City': 'A metropolis where technology and biology merge in perfect harmony.'
                    }
                };
                
                const typeDescriptions = descriptions[worldType];
                if (typeDescriptions && typeDescriptions[locationType]) {
                    return typeDescriptions[locationType];
                }
                
                return `A significant ${locationType.toLowerCase()} that plays an important role in this ${worldType} world.`;
            }
            
            displayWorld() {
                const worldInfo = document.getElementById('worldInfo');
                worldInfo.innerHTML = `
                    <h4>üåç ${this.currentWorld.type.charAt(0).toUpperCase() + this.currentWorld.type.slice(1)} World</h4>
                    <p><strong>Theme:</strong> ${this.currentWorld.theme || 'None specified'}</p>
                    <p><strong>Size:</strong> ${this.currentWorld.size} (${this.currentWorld.locations.length} locations)</p>
                    <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                        <strong>Description:</strong><br>
                        ${this.currentWorld.description}
                    </div>
                    <hr style="margin: 15px 0; border: 1px solid rgba(255,255,255,0.2);">
                    <h5>üó∫Ô∏è Locations:</h5>
                    <div style="max-height: 150px; overflow-y: auto;">
                        ${this.currentWorld.locations.map(loc => `
                            <div style="margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.03); border-radius: 3px; cursor: pointer;" onclick="worldGen.showLocationDetails('${loc.name}')">
                                <strong>${loc.name}</strong><br>
                                <small>${loc.description}</small>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            renderWorldMap() {
                const worldMap = document.getElementById('worldMap');
                worldMap.innerHTML = '';
                
                this.currentWorld.locations.forEach((location, index) => {
                    const locationElement = document.createElement('div');
                    locationElement.className = 'location';
                    locationElement.style.left = `${location.x}%`;
                    locationElement.style.top = `${location.y}%`;
                    locationElement.title = location.name;
                    
                    // Color-code locations by type
                    const colors = ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336', '#00BCD4', '#8BC34A', '#FFC107', '#E91E63', '#3F51B5'];
                    locationElement.style.background = colors[index % colors.length];
                    
                    locationElement.addEventListener('click', () => {
                        this.showLocationDetails(location.name);
                    });
                    
                    worldMap.appendChild(locationElement);
                });
            }
            
            showLocationDetails(locationName) {
                const chatInput = document.getElementById('chatInput');
                chatInput.value = `Tell me more about ${locationName}`;
                this.handleChat();
            }
            
            async handleChat() {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                if (!message) return;
                
                const worldInfo = document.getElementById('worldInfo');
                
                // Add user message
                const userMessage = document.createElement('div');
                userMessage.className = 'user-message';
                userMessage.innerHTML = `<strong>You:</strong> ${message}`;
                worldInfo.appendChild(userMessage);
                
                input.value = '';
                
                try {
                    let response = '';
                    
                    if (this.generator && this.currentWorld) {
                        // Create context for the AI
                        const context = `World Type: ${this.currentWorld.type}
World Description: ${this.currentWorld.description}
Locations: ${this.currentWorld.locations.map(l => l.name).join(', ')}

Question: ${message}
Answer:`;
                        
                        const result = await this.generator(context, {
                            max_new_tokens: 80,
                            temperature: 0.7,
                            do_sample: true,
                            pad_token_id: 50256
                        });
                        
                        response = result[0].generated_text.replace(context, '').trim();
                    } else if (this.currentWorld) {
                        // Fallback responses
                        response = this.generateFallbackResponse(message);
                    } else {
                        response = 'I need a world to be generated first! Please click "Generate New World" to create a world I can discuss.';
                    }
                    
                    const aiResponse = document.createElement('div');
                    aiResponse.className = 'ai-response';
                    aiResponse.innerHTML = `<strong>AI:</strong> ${response}`;
                    worldInfo.appendChild(aiResponse);
                    
                } catch (error) {
                    console.error('Error in chat:', error);
                    const aiResponse = document.createElement('div');
                    aiResponse.className = 'ai-response';
                    aiResponse.innerHTML = '<strong>AI:</strong> Sorry, I encountered an error. Please try again.';
                    worldInfo.appendChild(aiResponse);
                }
                
                worldInfo.scrollTop = worldInfo.scrollHeight;
            }
            
            generateFallbackResponse(message) {
                const lowerMessage = message.toLowerCase();
                
                if (lowerMessage.includes('location') || lowerMessage.includes('place')) {
                    const randomLocation = this.currentWorld.locations[Math.floor(Math.random() * this.currentWorld.locations.length)];
                    return `${randomLocation.name} is particularly interesting. ${randomLocation.description} It's a key location in our ${this.currentWorld.type} world.`;
                }
                
                if (lowerMessage.includes('world') || lowerMessage.includes('describe')) {
                    return `This ${this.currentWorld.type} world is fascinating! ${this.currentWorld.description.substring(0, 100)}... Would you like to know more about any specific location?`;
                }
                
                if (lowerMessage.includes('story') || lowerMessage.includes('adventure')) {
                    return `In this world, adventures await at every turn! You could start your journey at any of the ${this.currentWorld.locations.length} locations I've created. Each has its own unique characteristics and potential for storytelling.`;
                }
                
                return `That's an interesting question about our ${this.currentWorld.type} world! The world has ${this.currentWorld.locations.length} unique locations, each with its own story to tell.`;
            }
            
            saveWorld() {
                if (!this.currentWorld) {
                    this.updateStatus('No world to save!');
                    return;
                }
                
                const worldData = JSON.stringify(this.currentWorld, null, 2);
                const blob = new Blob([worldData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `world_${this.currentWorld.type}_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.updateStatus('World saved successfully!');
            }
            
            loadWorld() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                this.currentWorld = JSON.parse(e.target.result);
                                this.displayWorld();
                                this.renderWorldMap();
                                this.updateStatus('World loaded successfully!');
                            } catch (error) {
                                this.updateStatus('Error loading world file!');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }
            
            showLoading(show) {
                const loading = document.getElementById('worldLoading');
                loading.style.display = show ? 'block' : 'none';
            }
            
            updateStatus(message) {
                document.getElementById('status').textContent = message;
                setTimeout(() => {
                    document.getElementById('status').textContent = 'Ready';
                }, 3000);
            }
        }
        
        // Initialize the world generator
        window.worldGen = new WorldGenerator();
    </script>
</body>
</html> 